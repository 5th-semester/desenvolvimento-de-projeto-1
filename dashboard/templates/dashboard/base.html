{% load static %}

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>{% block title %}Análise de Rede WiFi{% endblock %}</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-100 font-sans">

    <nav class="bg-gray-800 p-4 text-white">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold">Análise de Rede WiFi</h1>
            <div>
                <a href="{% url 'primeiro_andar' %}" class="px-3 py-2 rounded hover:bg-gray-700">Primeiro Andar</a>
                <a href="{% url 'segundo_andar' %}" class="px-3 py-2 rounded hover:bg-gray-700">Segundo Andar</a>
            </div>
        </div>
    </nav>

    <main class="container mx-auto mt-8 p-4">
        {% comment %} Documentação: Este é o bloco de conteúdo.
             Cada página "filha" que herdar deste template irá
             inserir seu próprio conteúdo aqui. {% endcomment %}
        {% block content %}
        {% endblock %}

        <!-- Dashboard charts (histograma, scatter, stacked bar) -->
        <div class="quick-charts-wrapper mt-8">
        <section class="mt-0 bg-white p-6 rounded shadow-md">
            <h2 class="text-xl font-semibold mb-4">Visões Rápidas</h2>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div>
                    <h3 class="text-sm font-medium text-gray-700 mb-2">Distribuição de Potência (dBm)</h3>
                    <canvas id="chartHistogram" height="200"></canvas>
                </div>

                <div>
                    <h3 class="text-sm font-medium text-gray-700 mb-2">dbm vs Download (Mbps)</h3>
                    <canvas id="chartScatter" height="200"></canvas>
                </div>

                <div>
                    <h3 class="text-sm font-medium text-gray-700 mb-2">Boas x Ruins por Cômodo</h3>
                    <canvas id="chartStacked" height="200"></canvas>
                </div>
            </div>

            <p class="text-xs text-gray-500 mt-3">Os gráficos buscam dados em /api/summary/ — se não disponível, usam /static/dashboard/data.json como fallback.</p>
        </section>
        </div>

        <style>
          /* Constrain the quick charts wrapper to prevent layout-resize loops */
          /* Fixed-height wrapper prevents parent from growing when canvases attempt to resize */
          .quick-charts-wrapper { height: 460px; overflow: hidden; }
          .quick-charts-wrapper section { margin-bottom: 0; }
          /* Final safeguards: enforce fixed canvas pixel height (prevents Chart.js/CSS resize loops) */
          #chartHistogram, #chartScatter, #chartStacked { max-height: 380px; height: 380px !important; display:block; max-width:100%; }
        </style>

    </main>

    <script>
    // Force Chart.js to avoid pixel-ratio/responsive resizing loops
    if (typeof Chart !== 'undefined') {
        try {
            Chart.defaults.animation = false;
            Chart.defaults.devicePixelRatio = 1;
        } catch (e) {
            // ignore if Chart not available yet
        }
    }
    // small helpers to make charts robust against bad/missing data
    function toNumberSafe(v, def = 0) {
        const n = Number(v);
        return Number.isFinite(n) ? n : def;
    }

    // Classification rules mirror backend: good if dbm >= -60 and download >= 100 and interferencia <= 50
    function classifySignal(s) {
        const dbm = Number(s.dbm);
        const download = Number(s.download);
        const interfer = Number(s.interferencia);
        return (dbm >= -60 && download >= 100 && interfer <= 50) ? 'boa' : 'ruim';
    }

    function fetchSummary() {
        return fetch('/api/summary/')
            .then(resp => {
                if (!resp.ok) throw new Error('API returned ' + resp.status);
                return resp.json();
            })
            .catch(() => {
                // fallback to static file
                return fetch('/static/dashboard/data.json').then(r => r.json()).then(d => {
                    // try to normalize structure to { sinais: [...] }
                    if (Array.isArray(d)) {
                        return { sinais: d };
                    }
                    if (d.sinais) return d;
                    const sinais = [];
                    if (d.dados_segundo_andar) {
                        d.dados_segundo_andar.forEach(s => { s.comodo = 'Segundo Andar'; sinais.push(s); });
                    }
                    if (d.dados_primeiro_andar) {
                        d.dados_primeiro_andar.forEach(s => { s.comodo = 'Primeiro Andar'; sinais.push(s); });
                    }
                    return { sinais };
                });
            });
    }

    function renderCharts(data) {
        // prevent repeated initializations which can trigger resize loops
        if (window._chartsInitialized) {
            console.debug('Charts already initialized - skipping renderCharts');
            return;
        }
        const sinais = data.sinais || [];
        // Histogram bins (dbm ranges)
        const labels = ['<= -80', '-80 a -70', '-70 a -60', '-60 a -50', '> -50'];
        const counts = [0,0,0,0,0];

        const scatterPoints = [];
        const byComodo = {};

        sinais.forEach(s => {
            // normalize and validate numeric values, clamp extremes
            const rawDbm = toNumberSafe(s.dbm, 0);
            const rawDownload = toNumberSafe(s.download, 0);
            const rawInterfer = toNumberSafe(s.interferencia, 0);

            // clamp dbm to reasonable WiFi range [-100, 0]
            const dbm = Math.max(-100, Math.min(0, rawDbm));
            // clamp download to [0, 2000] Mbps
            const download = Math.max(0, Math.min(2000, rawDownload));
            const interfer = Math.max(0, Math.min(100, rawInterfer));

            // histogram
            if (dbm <= -80) counts[0]++;
            else if (dbm <= -70) counts[1]++;
            else if (dbm <= -60) counts[2]++;
            else if (dbm <= -50) counts[3]++;
            else counts[4]++;

            // scatter: only include valid numeric pairs
            if (Number.isFinite(dbm) && Number.isFinite(download)) {
                scatterPoints.push({ x: dbm, y: download });
            }

            // stacked bar per cômodo
            const com = s.comodo || (s.id && s.id <= 10 ? 'Segundo Andar' : 'Primeiro Andar');
            if (!byComodo[com]) byComodo[com] = { boa: 0, ruim: 0 };
            const status = (dbm >= -60 && download >= 100 && interfer <= 50) ? 'boa' : 'ruim';
            byComodo[com][status]++;
        });

        // Determine sensible axis limits
        const countsMax = counts.length ? Math.max(...counts) : 1;
        const histogramSuggestedMax = Math.max(5, countsMax + 1);

        const scatterYMaxRaw = scatterPoints.length ? Math.max(...scatterPoints.map(p => p.y)) : 100;
        // add 20% headroom but cap to a safe maximum
        const scatterYMax = Math.min(2000, Math.ceil(scatterYMaxRaw * 1.2));

        // Histogram
        const ctxH = document.getElementById('chartHistogram').getContext('2d');
        if (window._histChart) window._histChart.destroy();
        // force fixed canvas dimensions to avoid Chart.js auto-resize loops
        try {
            const canvasH = ctxH.canvas;
            const parentW = canvasH.parentElement ? canvasH.parentElement.clientWidth : 600;
            canvasH.style.width = parentW + 'px';
            canvasH.style.height = '380px';
            canvasH.width = parentW;
            canvasH.height = 380;
        } catch (e) {
            // ignore sizing errors
        }
        window._histChart = new Chart(ctxH, {
            type: 'bar',
            data: { labels, datasets: [{ label: 'Pontos', data: counts, backgroundColor: '#60a5fa' }] },
            options: { responsive: false, maintainAspectRatio: false,
                scales: { y: { beginAtZero: true, suggestedMax: histogramSuggestedMax } }
            }
        });

        // Scatter
        const ctxS = document.getElementById('chartScatter').getContext('2d');
        if (window._scatChart) window._scatChart.destroy();
        try {
            const canvasS = ctxS.canvas;
            const parentW = canvasS.parentElement ? canvasS.parentElement.clientWidth : 600;
            canvasS.style.width = parentW + 'px';
            canvasS.style.height = '380px';
            canvasS.width = parentW;
            canvasS.height = 380;
        } catch (e) {}
        window._scatChart = new Chart(ctxS, {
            type: 'scatter',
            data: { datasets: [{ label: 'dbm vs download', data: scatterPoints, backgroundColor: '#34d399', pointRadius: 5 }] },
            options: {
                responsive: false,
                maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'dbm (mais negativo = pior)' }, min: -100, max: 0 },
                    y: { title: { display: true, text: 'Download (Mbps)' }, min: 0, max: scatterYMax }
                }
            }
        });

        // Stacked bar
        const comodos = Object.keys(byComodo);
        const boas = comodos.map(c => byComodo[c].boa);
        const ruins = comodos.map(c => byComodo[c].ruim);

        const ctxB = document.getElementById('chartStacked').getContext('2d');
        if (window._stackChart) window._stackChart.destroy();
        try {
            const canvasB = ctxB.canvas;
            const parentW = canvasB.parentElement ? canvasB.parentElement.clientWidth : 600;
            canvasB.style.width = parentW + 'px';
            canvasB.style.height = '380px';
            canvasB.width = parentW;
            canvasB.height = 380;
        } catch (e) {}
        window._stackChart = new Chart(ctxB, {
            type: 'bar',
            data: {
                labels: comodos,
                datasets: [
                    { label: 'Boas', data: boas, backgroundColor: '#10b981' },
                    { label: 'Ruins', data: ruins, backgroundColor: '#ef4444' }
                ]
            },
            options: { responsive: false, maintainAspectRatio: false, animation: false, scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } } }
        });

        // mark charts as initialized so we don't re-render and trigger layout loops
        window._chartsInitialized = true;
    }

    // Inicializa
    fetchSummary().then(renderCharts).catch(e => console.error('Erro ao carregar dados para os gráficos', e));
    </script>

</body>
</html>